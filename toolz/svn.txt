Berserk Svn Red Bean

1. Вводная

2. Basic Work Cycle

svn import
^^^
для записи дерева без рабочей директории!

svn list ^/
^^^
покажет корень репозитория, адрес которого берёт из локальной рабочей копии
Для суб-директорий фишка не работает, там всегда будет только начальный адрес и всё, все подпроекты надо вписывать от начала

svn checkout http://adress/trunk dir/to/locate
^^^
Создание рабочей копии
Теоретически, её нужно создавать всего один раз, а дальше только обновлять

svn update
^^^
Смёржит все изменения в центральном репозитарии с локальной копией, сохраняя локальные изменения
Если правим файл, то его не надо явным образом добавлять!! Он будет автоматом помечен как изменённый и типа в состав commit-а
Если меняем структуру дерева ФС, то надо svn командовать об этом

svn add HR
^^^
добавляем новый объект в рабочую копию (файл или директорию рекурсивно)

svn delete HR
^^^
удаляем объект (начиная только с текущего HEAD и далее, естественно)

svn copy HR BR
^^^
Создание копии объекта HR; это означает то же содержание в BR, что в HR, отсутствие физического копирования (раздублирования объёма), + BR наследует историю HR

svn move HR BR
^^^
Алиас для svn copy HR BR + svn delete HR

svn mkdir HR
^^^
Алиас для mkdir HR ; svn add HR

svn status HR
^^^
показывает все изменения для объекта HR по сравнению с последней скачанной версией
? - объект не добавлен в svn
A - объект будет добавлен при коммите
M - объект отредактирован
D - объект удалён
С - объект в конфликте: локальные изменения пересеклись с обновлениями от сервака, и их не удалось совместить автоматикой
G - объект смержен при обновлении

svn status -v
^^^
пишет в выводе все файлы рабочей копии, без изменений в том числе
плюс там более интересный формат вывода - там показывается номер ревизии, к которой принадлежит файл, и номер последней ревизии, в какой этот файл менялся(!) - неплохо.

svn status -v -u
^^^
вот эта команда в отличие от остальных, лезет в сеть, и загружает об изменениях на сервере, пока тебя не было. 
Звёздочками она отмечает файлы, которые обновились, и которых нет у тебя в рабочей копии

svn diff HR
^^^
Пишет локальные изменения в diff-формате, аняня

svn revert HR
^^^
отмена любого действия с рабочей копией (объектом HR), возвращает объект в изначальное состояние
можно разудалить на место удалённый файл
но! нельзя вернуть удалённые директории

svn update --non-interactive
^^^
Когда overдофига конфликтов, обновлять всё молча, помечая каждый конфликтный файл C, которые можно будет разрулить потом

svn resolve --accept working sandwich.txt
^^^
Разруливание конфликтов для кривого файла, стратегии:
--accept working - взять файл, который отредактировал ты, убрав конфликтные маркеры
Тут следует помнить, что резолвить надо аккуратно, можно закоммитить файл с неудалёнными маркерами конфликта, они не проверяются
--accept theirs-full - взять целиком ихний файл
--accept mine-full - взять целиком свой файл
--accept mine-conflict - игнорировать внешние обновления, которые конфликтуют с локальными изменениями; но которые не конфликтуют - те брать
--accept theirs-conflict - то же самое, но для удалённых изменений

filename.mine, filename.rNUMOLD, filename.rNUMNEW
^^^
три файла, которые заводятся для каждого (!) конфликтного файла
mine - твоя локальная версия с правками до апдейта; rNUMOLD - версия файла до твоих изменений; 
rNUMNEW - новое состояние файла на сервере

svn commit
^^^
счастливо коммитим нашу лабуду
svn commit -m "мессага"
^^^
короткий коммент к коммиту
svn commit -F filename
^^^
возьмёт текст из файла
Чтобы отменить коммит, когда коммент пишешь в редакторе, можно или не сохранять текст, или удалить его весь и сохранить, а потом svn-у сказать abort

******************

svn diff -r 2:3 rules.txt
^^^
Получение разницы между коммитами в svn, йахуууу

svn log -r 19:5 foo.c
^^^
Смотрим историю коммитов с 5 по 19 ревизию в обратном хронологическом порядке для файла foo.c
В истории отображаются только номера ревизий и комменты

svn log -v
^^^
История со списком файлов, которые были модифицированы

svn diff -r 3 rules.txt
^^^
Сравнение рабочей копии с состоянием на сервере в ревизии 3

svn diff -c 5 rulse.txt
^^^
получаем разницу между ревизией 5 и 4

svn log -rHEAD:123 OBJ
^^^
Историю с последней ревизии до 123-й

svn cat -r 2 rules.txt
^^^
смотрим файл в ревизии 2

svn list -v http://svn.example.com/repo/project
^^^
ls для svn, -v для verbose

svn update -r 1729
^^^
делаем локальную рабочую копию как в ревизии

svn co URL@172 my-trunk
^^^
рекомендуемый способ получать директорию по состоянию старых ревизий

svn export
^^^
выгружаем файлы без .svn

svn cleanup
^^^
Команда ищет непроведённые транзакции svn в рабочей копии, доделывает до конца и снимает блокировки (locks) с 
файлов, которые в транзакции участвовали; это может быть при вырывании на свободу Ctr+C во время какой-то 
хоз.деятельности у SVN

svn info
^^^
Подробная информация о происхождении svn-объекта;
Кроме того, для tree-конфликтов показывает оба источника конфликта!

3. Advanced Topics

svn cat -r 1 concept/IDEA@BASE
^^^
Ыщ! Спрашиваем отобразить текущий файл IDEA в том состоянии, в котором он был в ревизии 1
@BASE - это указатель "Peg revision", который нужен для того, чтобы разбираться, на какие файлы мы указываем:
на текущие в старой версии, или на _другие файлы с тем же именем_, которые присутствовали в прошлой версии
Соотсно, можно указывать @num для того, чтобы показывать на фактический файл, а оперативные ревизии (-r) для того, чтобы задавать диапазон действий с этим файлом, как бы он ни назывался в этом диапазоне

svn cat concept/IDEA@1
^^^
Показываем на файл с адресом и названием, которые были действительны на момент ревизии 1

svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
^^^
Показываем на файл, который лежал по такому-то адресу в ревизии 20, и затем показываем изменения, которые произошли с ним с четвёртой ревизии по десятую, как бы он при этом ни назывался раньше!

svn checkout http://svn.example.com/svn/repo/trunk@1729 oldworkdir
^^^
Создаём рабочую копию репозитория на момент ревизии 1729, полный возврат во времени

svn checkout http://svn.example.com/svn/repo/trunk -r 1729 oldfilesdir
^^^
Создаём рабочую копию репозитария с нынешней _структурой_, но старым состоянием файлов

svn export http://addr
^^^
создание релиза! выкачивание файлов без .svn

svn cleanup
^^^
Разрулить залоченные файлы, которые остались запертыми после незавершённых операций svn - которые попали в todo list для транзакции, но не выполнились из-за обрыва действй svn

-rBLAHBLAH
^^^
Ключевые слова для ревизий!

HEAD
^^^
Самый последний момент в репозитории

BASE
^^^
номер ревизии для штуки из локального репо, причём не включающую локальные изменения 

COMMITED
^^^
близжайший номер к BASE, в котором локальные изменения включены

PREV
^^^
COMMITED-1, кхы-кхы

svn checkout -r {2006-02-17}
^^^
идентификатор ревизии по времени! Причём эти фигурные кавычки надобно экранировать, скорее всего
Дата принимается в формате ISO-8601, и возможно в других
Для широкого диапазона в дате берётся самое свежее состояние
Причём! для даты дня возьмётся время 00:00, и потом svn пойдёт искать самое "раннее" состояние, то бишь отматывать время назад
То бишь оно выдаст состояния с предыдущего дня - поэтому надо делать в дне дату +1
Также пердуперждают, что если даты менялись вручную через setprop, то конвертация дата->номер ревизии может выдавать глюки, если ревизии меняли местами

svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
^^^
установка свойства copyright в значение 'тащемта например' 

svn propset license -F /path/to/LICENSE calc/button.c
^^^
файл, который содержит значение свойства (оно может быть и бинарным)

svn proplist calc/button.c
^^^
выдаёт список свойств на узле

svn propget <propname> calc/button.c
^^^
выдаёт значение свойства propname на узле

svn proplist -v calc/button.c
^^^
Вывод всего сразу - свойств и значений

svn propdel license calc/button.c
^^^
убийство свойства

.subversion/config
use-commit-times = yes
^^^
значение настроек, чтобы даты файлов выставлялись не от времени апдейта, а от времени их коммита
Для сохранения оригинальных datestamp-ов это бесполезно, потому что при коммите они портятся так или иначе
Если же их менять в рабочей копии после коммита, то svn не считает это апдейтом и файлы не перекачивает - что хорошо
Значит, можно настроить хук на принудительный возврат оригинальных time-штампов

svn propset hrdate "`stat -c %y $filename`" $filename
touch -d "`svn propget hrdate $filename`" $filename
^^^
вот тебе и хуки, только в циклы загнать
на практике оказалось несколько геморройнее - это возможно только на клиентской стороне, но не на сервере
Ибо на сервере уже нет доступа к файлам рабочей копии, с которой закоммитили

svn propset svn:log "* button.c: Fix a compiler warning." -r11 --revprop \
              http://svn.example.com/repos/project
^^^
добавляем опцию --revprop и теми же командами правим свойства для ревизий целиком
(с указанием полного урла - ещё и без рабочей копии)
Кроме того, будет нелищне помнить, шо для модификации свойств ревизий, которые не версионируются, нужно в конфигах svn-сервака специально выставлять разрешение

svnadmin create `pwd`/svn
svnserve -d -r `pwd`/svn
svn checkout file://localhost/home/ton/arena/svn
^^^
для тестов локального сервака

.subversion/config, global-ignores
^^^
конфиг для глобального забивания на добавление через svn add \ import

svn propset svn:ignore -F .cvsignore .
^^^
ставим свойство для забивания на файлы для конкретной директории в рабочей копии

svn add --force .
^^^
добавление новых файлов с уважением к svn:ignore

svn add *
svn add --no-ignore .
^^^
забивание на svn:ignore, либо по опции, либо из-за явного указания целей, которое происходит при раскрытии спец-символов шелла
Если командовать так, то свойство svn:ignore не выполнится

svn propset svn:keywords "Date Author" weather.txt
^^^
Офигенно! включение "Расширения ключевых слов"
В файл включаем текстовые якоря, которые дописываются последними значениями при коммите
В build такой можно зафигачить
По дефолту ничего подставляться не будет, надо вручную свойство для файла выставить

Sparse directories

svn add --depth=empty HR
^^^
добавляем только директорию без содержимого
опция depth запоминается в рабочей копии!
svn update --set-depth files
^^^
опция set-depth для изменения сохранённой опции depth

*****

Merging



------------------------------------

Combos

svnadmin create /var/svn/repos
^^^
простое создание репо по умолчанию

svnadmin create --fs-type fsfs /var/svn/repos
^^^
то же самое, что выше, но с явным указанием файлового back-end-а. 
Возможен ещё вариант bdb, который нам не подходит совсем-совсем

svnserve -d -r /net/maa/export/home/tmp/ton/poligon

svn resolve --accept working -R .
^^^
разрулить tree conflict при удалении директорий в рабочей копии

svn status | grep "^\?" | awk '{print $2}' | xargs svn add 
^^^
добавить рекурсивно все новые файлы в директории

svn status | grep "^\?" | awk '{print $2}' | xargs svn add ; client-hook-precommit.sh `pwd`
^^^
с необходимым хуком на клиентской стороне

svn checkout ^/dir/dir --depth empty
^^^
скачать рабочую копию, не скачивая содержимое

svn list -vR svn://maa:/repo/elbrus/trunk/src | awk '{if ($3 !="") sum+=$3; } END {print sum/1024000 }'
^^^
узнать размер скачиваемого, в мегабайтах

svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/newbranch \
         -m "Create branch 'newbranch'."
svn switch ^/calc/branches/newbranch
^^^
создание ветки для своих изменений и продолжение работы там

svn co --username admin1 --password pass1
^^^
коммиты от произвольных юзеров

svn diff --summarize
^^^
Дифф только со списком файлов

svn merge -c -392 URL
^^^
отменить коммит с номером 392

------------------------------------

deeps & weirds

Любопытное про задачу сохранения дат в коммите через хук, из оф.мануала:
http://svnbook.red-bean.com/nightly/en/svn.reposadmin.create.html

While hook scripts can do almost anything, there is one dimension in which hook script authors should show restraint: do not  modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors, shortcomings, or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably stale. This inconsistency can lead to surprising and unexpected behavior. Instead of modifying the transaction, you should simply validate the transaction in the pre-commit hook and reject the commit if it does not meet the desired requirements. As a bonus, your users will learn the value of careful, compliance-minded work habits.

оло-ло, надо искать способ "легального" сохранения даты файлов

~-=~-=~-=~-=~-=~-=~-=

Svn хранит локальную копию неизменённых данных в .svn
Это позволяет делать всякие реверты, откаты и сравнения, не привлекая сервер
Теоретически это будет увеличивать размер рабочей копии примерно вдвое против размера самих файлов
На свежескачанной копиии все .svn весят по 40 килобайт - то бишь такое наблюдается далеко не всегда

~-=~-=~-=~-=~-=~-=~-=

В start-commit можно загнать хук, который запустит чекер на вливаемую хрень - он запускается до создания транзакции
Нельзя его туда загнать, увы - ты на этот момент не будешь иметь доступа к файлам
Печаль хуков сервера в том, что ты можешь обращаться только к данным транзакции \ ревизии, то есть к данным, которые уже попали на сервер, и 
в том виде, в каком они оказались после формирования транзакции svn-ом
Доступа к локальной файловой системе коммитера нету =(

~-=~-=~-=~-=~-=~-=~-=

Даты итогово решаются грустно - через хук на стороне клиента, который дефолтовый svn не поддерживает (только всякие с графическими мордами)
То бишь надо будет или пускать ручками, или делать какую-то обёртку

~-=~-=~-=~-=~-=~-=~-=

