Git Berserker

#1.

git clone git://git.kernel.org/pub/scm/git/git.git
^^^
добываем копию гита

git init
^^^
либо создаём новый репо в текущей директории

******************
обзорные команды

git branch
^^^
просмотр текущих веток

git tag -l
^^^
просмотр текущих тэгов

git checkout -b tagged-br v2.6.13
^^^
создать новую ветку tagged-br, голова которой будет указывать на состояние проекта, отмеченное тэгом v2.6.13
То бишь можно дальше параллельно всему развивать ветку 2.6.13.x

git reset --hard v2.6.17
^^^
переставить голову текущей ветки на указанный тэг
При этом указатель на текущее состояние затирается; если других указателей не было, помимо бывшей головы, то мы имеем шанс пролюбить последнюю историю

checkout - это переключение рабочей копии на существующие ветви, не изменяя их; reset - это изменение положения головы в текущей ветке

git show
^^^
показать последний комит в кошерном формате - и тебе коммент, и пути к файлам, и diff

gitk
^^^
графическая морда для просмотра истории

******************
Работа с ветками:

git branch
^^^
Список веток

git branch <name> [<start>]
^^^
Создание новой ветки name, у которой HEAD будет показывать на start
start задаётся всем - веткой, тегом или коммитом

git checkout -b <name> [<start>]
^^^
То же самое, но ещё и зачекаутиться туда

git checkout <name>
^^^
Переключить рабочую копию на состояние name - точно так же может быть ветка \ тег \ коммит

git branch -d <name> 
^^^
с предосторожностями удалить ветку name

git branch -D <name>
^^^
Удалить name даже в том случае, если name недостижим по истории из текущей головы
Для случая, если знаешь, что name доступен из другого состояния или нужно удалить вообще с концами (чего, впрочем, не стоит делать)
Удобно удалять произвольные ненужные ветки, не переключаясь на их родителей

******************
Имена

HEAD
^^^
Спец-символ для указания на текущее положение головы
Оно чаще всего совпадает с последним коммитом в ветке (и совпадает с названием ветки), либо равно тегу
Если же лазили по глуши и переключались на произвольные коммиты, оно будет равно хешу коммита

git branch -r
^^^
выдаёт названия всех удалённых веток, которые палятся текущим репозитарием
Если он создавался с нуля локально (git init), то ничего не выдаст
Если клонировался или pull-ился откуда-то, то покажет ветки удалённого репозитария:
  origin/HEAD -> origin/master
  origin/base.fresh
  origin/master

origin
^^^
название по умолчанию для удалённого репозитария, с которого склонировали текущий

refs/heads/test
^^^
формат полного названия для объектов, этот для веток

refs/tags/v2.6.18
^^^
этот для тегов

refs/remotes/origin/master
^^^
этот для удалённых веток
всех их можно использовать в качестве полноценных идентификаторов - чекаутиться, теггироваться с них и тыды

origin/HEAD
^^^
ветвь по умолчанию в репозитарии; к ней можно обращаться просто как к origin

git remote add <reponame> <repoaddress>
git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git
^^^
добавление нового репозитария для удалённого палева

git fetch
^^^
обновление состояния всех удалённых веток, которые палятся текущим репозитарием; собственные локальные ветки не трогаются, независимо от того, как они ветвятся от удалённых

git fetch <name>
^^^
обновление удалённых веток только для указанного репозитария

--------------------------------------------------------

Git combos

http://schacon.github.com/git/user-manual.html

Создание тарбола

git archive e2k.stable.rpath | gzip > ~/test/e2k.stable.rpath.tgz
git archive slack.stable.current | gzip > ~/efs/svn/slack.stable.current.tgz

Просмотр всех файлов

git log e2k.oldstable.gstuff --pretty=format: --name-only --diff-filter=A | sort - >& list.files

Копирование себе репозитория

vim ~/.gitconfig

[user]
         name = ton
         email = ton@sample.ru
[i18n]
    commitencoding = ru_RU.UTF-8

rm -rf ./repo
git clone -n --template /dir/git/templates /auto/allarch/osfs.git ./repo
cd ./repo
git fetch origin slack.stable.current:slack.stable.current
git checkout slack.stable.current

Обновление удалённого репозитария
git push /auto/allarch/osfs.git slack.stable.current:slack.stable.current

Обновление рабочего репо с удалённого репозитория
git pull /auto/allarch/osfs.git slack.stable.current

Срезание новой ветки newbranch 

git branch newbranch

Переключение на ветвь
git checkout slack.debug

сливание ветки new в ветку main

git checkout main
git merge new

Спасительная команда undo:
git reset --hard HEAD

git diff branch1..branch2 file.txt
^^^
выдаём diff для файла для изменений, которые есть в branch2, но нет в branch1

git fetch 
команда, качающая внутренние структуры гиторепозитариев с удалённых мест

Посмотреть, какие ветки есть в произвольном удалённом репозитории (не в том, с которого склонировали)
git remote add svetlana /home/shishor_s/repo
git fetch svetlana
git branch -r
^^^
теперь команда будет показывать её ветки среди всех остальных удалённых
(других таких же добавленных и того, с которого склонировали главный репо)


-------------------------------------------------

Действия по запиливанию удалённого репозитория

git init
^^^
создаём нулевой репо 
ssh-keygen -t rsa -C "net@rlib.su"
^^^
генерим пару rsa-ключей
git remote add origin git@github.com:rlib/allinfo.git
^^^
связываемся с удалённым серваком
git push -u origin master
^^^
заливаем всё из ветки master
git push origin base.fresh:base.fresh
^^^
заливаем всё из ветки base.fresh и одновременно создаём эту ветку, если её не было

Доступ из-под прокси к удалённому гит-репо!

ставим программу для форвардинга ssh-трафика через http - 
corkscrew

дальше создаём ~/.ssh/config, туды пишем:

Host github.com
  ProxyCommand /path/to/corkscrew proxy.host.com 80 %h %p
  User git
  Hostname ssh.github.com
  PreferredAuthentications publickey
  Port 443
  IdentityFile "/path/to/.ssh/id_rsa"
  TCPKeepAlive yes
  IdentitiesOnly yes

И всё, git дотягивается до github как ни в чём ни бывало
