Git Berserker

#1.

git clone git://git.kernel.org/pub/scm/git/git.git
^^^
добываем копию гита

git init
^^^
либо создаём новый репо в текущей директории

******************
обзорные команды

git branch
^^^
просмотр текущих веток

git tag -l
^^^
просмотр текущих тэгов

git checkout -b tagged-br v2.6.13
^^^
создать новую ветку tagged-br, голова которой будет указывать на состояние проекта, отмеченное тэгом v2.6.13
То бишь можно дальше параллельно всему развивать ветку 2.6.13.x

git reset --hard v2.6.17
^^^
переставить голову текущей ветки на указанный тэг
При этом указатель на текущее состояние затирается; если других указателей не было, помимо бывшей головы, то мы имеем шанс пролюбить последнюю историю

checkout - это переключение рабочей копии на существующие ветви, не изменяя их; reset - это изменение положения головы в текущей ветке

git show
^^^
показать последний комит в кошерном формате - и тебе коммент, и пути к файлам, и diff

gitk
^^^
графическая морда для просмотра истории

******************
Работа с ветками:

git branch
^^^
Список веток

git branch <name> [<start>]
^^^
Создание новой ветки name, у которой HEAD будет показывать на start
start задаётся всем - веткой, тегом или коммитом

git checkout -b <name> [<start>]
^^^
То же самое, но ещё и зачекаутиться туда

git checkout <name>
^^^
Переключить рабочую копию на состояние name - точно так же может быть ветка \ тег \ коммит

git branch -d <name> 
^^^
с предосторожностями удалить ветку name

git branch -D <name>
^^^
Удалить name даже в том случае, если name недостижим по истории из текущей головы
Для случая, если знаешь, что name доступен из другого состояния или нужно удалить вообще с концами (чего, впрочем, не стоит делать)
Удобно удалять произвольные ненужные ветки, не переключаясь на их родителей

******************
Имена

HEAD
^^^
Спец-символ для указания на текущее положение головы
Оно чаще всего совпадает с последним коммитом в ветке (и совпадает с названием ветки), либо равно тегу
Если же лазили по глуши и переключались на произвольные коммиты, оно будет равно хешу коммита

git branch -r
^^^
выдаёт названия всех удалённых веток, которые палятся текущим репозитарием
Если он создавался с нуля локально (git init), то ничего не выдаст
Если клонировался или pull-ился откуда-то, то покажет ветки удалённого репозитария:
  origin/HEAD -> origin/master
  origin/base.fresh
  origin/master

origin
^^^
название по умолчанию для удалённого репозитария, с которого склонировали текущий

refs/heads/test
^^^
формат полного названия для объектов, этот для веток

refs/tags/v2.6.18
^^^
этот для тегов

refs/remotes/origin/master
^^^
этот для удалённых веток
всех их можно использовать в качестве полноценных идентификаторов - чекаутиться, теггироваться с них и тыды

origin/HEAD
^^^
ветвь по умолчанию в репозитарии; к ней можно обращаться просто как к origin

git remote add <reponame> <repoaddress>
git remote add linux-nfs git://linux-nfs.org/pub/nfs-2.6.git
^^^
добавление нового репозитария для удалённого палева

git fetch
^^^
обновление состояния всех удалённых веток, которые палятся текущим репозитарием; собственные локальные ветки не трогаются, независимо от того, как они ветвятся от удалённых

git fetch <name>
^^^
обновление удалённых веток только для указанного репозитария

--------------------------------------------------------

#2.

git bisect start
git bisect good v.1.1.1
git bisect bad v.1.1.2
^^^
начало алгоритма бинарного поиска плохого коммита, на котором всё валится, а на предыдущем - нет

git bisect bad
git bisect good
^^^
отметка о результате, когда гит чекаутит очередной коммит при поиске

git bisect reset
^^^
вернуться к начальному положению до юзанья bisect

******************
Способы указывать на references в истории

git show <hash>
git show <branch>
^^^
Красиво кажем для указанного reference (покажет только один последний коммит)

git show HEAD^
^^^
пред-последний коммит 

git show HEAD^^
^^^
пред-пред-последний коммит

git show HEAD~4
^^^
отмотать на 4 назад

git show HEAD^1
git show HEAD^2
^^^
показать первого или второго (!) родителя коммита


******************
Собсно история

git log
^^^
текущая история

git log sha1
^^^
история, ведущая к указанному коммиту

git log sha1..
^^^
история, ведущая _из_ коммита

git log sha1..tag-111
^^^
история между sha1 и tag-111

git log sha1...tag-111
^^^
история из sha1 и tag-111 до их слияния
(коммиты, идущие от какой-либо из меток, но не обеих)

git log --since="2 weeks ago"
^^^
фильтруем по дате

git log fs/*
^^^
только коммиты, затронувшие файлы из маски

git log -S'foo()'
^^^
строка поиска, которая должна присутствовать в диффах коммитов (!!!)

git log -p
^^^
история в формате git show

git log --pretty=short,medium,full,fuller
^^^
формат форматирования логов
что смешно, там нет того режима, который даёт git log -p

git whatchanged
^^^
кажет коммит, полный коммент и изменённые файлы
вот он, вот он, лог моей мечты

******************
Полезное

git rev-parse <ref>
^^^
показать sha1-хеш коммита для его символьного имени (!)

git tag nametag sha1sum
^^^
создать легковесный тег "nametag" для коммита "sha1sum"
типа алиаса в истории

git show ref:path/to/file
^^^
показать файл в указанном коммите, не чекаутя ничего

git diff master..test
^^
Создать патч, который после наложения сделает из состояния test состояние master

git rev-list ref1..ref2
^^^
список sha1 коммитов между ref1 и ref2

******************
Определение родительства и потомков

git name-rev --tags e05db0fd
^^^
найдёт ближайший тег, который содержит наш коммит, и выдаст через него название, наподобие
e05db0fd tags/v1.5.0-rc1^0~23

git describe e05db0fd
^^^
выдаст название тега, от которого тянется наш коммит

git merge-base ref1 ref2
^^^
выдаёт общего потомка!
И если один ref1 - родитель второго, то его и выдаст

git show-ref
^^^
показывает полные ref-ы для идентификаторов (и sha1 тоже)

git show-ref --heads
^^^
показать все рефы к веткам

git show-ref --tags
^^^
все теги соответственно

--------------------------------------------------------

#3.

git add /path
^^^
Добавить новые файлы либо добавить изменения в существующих файлах

git rm /path
^^^
Удаление и из гита, и из рабочей копии

Здесь есть два указателя: HEAD и индекс
HEAD - указатель на последнее закоммиченное состояние
индекс - указатель на последнее добавленное, но не закоммиченное

git diff --cached
^^^
разница между HEAD и индексом
(что будет, если сделать commit)

git diff
^^^
разница между фактическими файлами и индексом
(что не добавлено в git)

git diff HEAD
^^^
что будет, если сделать git commit -a

git commit
^^^
закоммитить состояние из индекса

git commit -a
^^^
перенести в индекс всё, что туда ещё не добавлено, и закоммитить

******************
Слияние

git merge branchname
^^^
Сливааааемся
Кстати, коммит здесь происходит сразу

git status
^^^
Собсно, рассказывает всякое про редактированное, но незакоммиченное, в файле

MERGE_HEAD
^^^
временный индекс, который отмечает HEAD у ветки, которую мы слили с текущей

>>>>>>>>
^^^
Маркеры для конфликтов внутре файла

:1:file.txt
^^^
файл после слияния

:2:file.txt
^^^
Версия из бывшей HEAD

:3:file.txt
^^^
Версия из MERGE_HEAD

-
 -
++
^^^
Формат diff при merge!
Первая колонка показывает, что произошло с текстом из бывшего HEAD
Вторая колонка показывает про MERGE_HEAD

git diff -1, git diff --base
^^^
Сравнение рабочей копии с состоянием после merge

git diff -2, git diff --ours
^^^
С локальным HEAD

git diff -3, git diff --theirs
^^^
С MERGE_HEAD

Когда мы успешно проворачиваем коммит с вливом, хранение всех этих состояний (1, 2, 3) прекращается!

******************
Откаты

git reset --hard HEAD
^^^
Вернуть текущий индекс к последнему закоммиченному HEAD
Это выбросит все изменения, внесённые в индекс

git reset --hard ORIG_HEAD
^^^
Выбросить последний коммит, возвращаясь к предыдущему(!)
Рекомендуют применять с большой осторожностью, и коммит нельзя выкидывать, если он уже был смёржен куда-то ещё

git commit --ammend
^^^
Выбросить последний коммит и заменить его теми изменениями, что сделали в текущем индексе рабочей копии

Если в сливаемых ветках нет реальных отличий по содержанию файлов, будет "Fast Forward" - индекс текущей ветви передвинется вперёд и всё, коммитов не будет

git revert <ref>
^^^
Создание нового коммита, который откатит указанный ref

git checkout ref /path/to/file
^^^
Откатит указанный файл в рабочей копии на указанный ref!!!

git stash save "comment"
^^^
схоронить в специальном "буфере для индексов" текущие изменения, которые были сделаны, но не закоммичены

git stash pop
^^^
Достать эти изменения из буфера

git log master@{2}
^^^
посмотреть, куда показывала HEAD ветки 2 коммита назад(!)
эта хрень называется "Reflog"

git log master@{"1 week ago"}
^^^
ни фига себе

git show HEAD@{yesterday}
^^^
то же самое для HEAD репозитария

git log --walk-reflogs master
^^^
Посмотрить все reflogs для ветки
Это по сути работа с историей переключения между ветками
Она хранится по умолчанию 30 дней, и между разными репозитариями не расшаривается!

git log <sha1s> --not --all
^^^
гыг, посмотреть историю, которая достижима только из указанного ref, но не их любых других
Таким образом можно найти коммит, который удалили, но который показывает на какую-то историю, недостижимую из другого места
Если нашли, от sha1s можно ответвиться

******************
Всякое

.gitignore
^^^
Файл с шаблонами для игнора файлов при git add . и всяком таком
Можно его самого закоммитить, и тогда при пуллах он появится в других репо

git gc
^^^
Перепаковывание архива, экономия места \ памяти
Жрёт время, надо запускать профилактически

git fsck
^^^
типа проверка файловой системы репозитария

--------------------------------------------------------

#4.

**********
пресвятые pull и push

git pull origin master
^^^
Слить обновления из удалённого репо origin, ветки master, в текущую ветку
Эквивалентно вызову
git fetch ; git merge origin/master
Для случая origin/master можно не указывать аргементов - они по умолчанию, просто git pull
ЭТо если текущий master зачекаучен
git pull, как и git merge, создаёт коммит!

git pull . branch
^^^
"грубый" эквивалент git merge branch

git pull URL
^^^
вытянуть обновления с репозитария по произвольному урлу

git push URL master:master
^^^
запихать обновления из локальной ветви master в репо по URL-у в удалённую ветку master
Мега-коммент! Предполагается, что запихивать можно только в голый (bare) репозитарий, у которого нет
checkout-ных файлов
В этом случае все служебные файлы у него находятся в корневой директории (а не в .git, как в check-out-ном)
При этом есть соглашение, что такие публичные репо должны называться по типу proj.git
push НЕ обновляет содержимое, которое отображено в ФС через check-out, и не советуют связываться с 
ситуацией, когда ветвь репо по умолчанию отчекаутнута, а в неё запихали удалённо

*********
обмениваться патчами

git format-patch origin
^^^
создать серию патчей, которые доводят состояние ветви origin/HEAD до состояния в текущей ветви

git am -3 patches.mbox
^^^
запатчить в текущую ветвь патчи, сделанные через format-patch
-3 - для создания merge

git am --resolved
^^^
запускать после того, как разрезолвили конфликты при мердженьи патчей (вместо коммита)
в результате получится серия коммитов (!), которую перенесли через патчи

*********
запилить свой публичный репозитарий

git clone --bare ~/proj proj.git
^^^
Склонировать только мета-информацию, но не содержимое

touch proj.git/git-daemon-export-ok
^^^
сказать демонам гита и всем их заместителям, что этот репо - публичный, и его можно раздавать

git daemon
^^^
запустить демона, который будет слушать порт 9418 и раздавать все репозитарии на сервере, которые объявлены как публичные
получать доступ можно будет по протоколу git://

git daemon dir
^^^
раздавать только из поддиректорий dir

git --bare update-server-info
mv hooks/post-update.sample hooks/post-update
^^^
процедура, указанная для поднятия гита через http

********
связь удалённых и локальных ветвей

git branch --track <newname> origin/master
git branch -t <newname> origin/master
^^^
при создании ветки сказать, что её "upstream" версия - origin/master
после этого git pull будет по умолчанию вытаскивать обновления из origin/master 

git branch --set-upstream
^^^
задать upstream ветвь для существующей локальной ветви

cat >> .git/config <<EOF
[remote "mytree"]
        url =  master.kernel.org:/pub/scm/linux/kernel/git/aegl/linux-2.6.git
        push = release
        push = test
EOF
^^^
настройки для push, которые позволят запихивать ветвь по умолчанию в нужный URL 

git push mytree
^^^
все ветви, указанные в конфиге, запихнет в УРЛ из конфига и upstream ветку


--------------------------------------------------------

Git combos

git checkout -b speed-up-spinlocks v2.6.35
.. do work..
git checkout test && git pull . speed-up-spinlocks
^^^
цикл внесения измнений: 
- создаём ветку для мега-фишки с тега v2.6.35
Тег используется затем, чтобы вносить в проверенное состояние, и не накладывать нетещенное на другое нетещенное
- чекаутим публичную ветку (test) и обновляем её из ветки-фишки
в чём разница между pull . branch и merge branch, непонятно пока

git log linux..branchname | git shortlog
^^^
посмотреть список изменений в ветке

git log origin..branchname
^^^
посмотреть, замёржена ли ветка в какую-то релизную линию
если будет вывод, то НЕ-замёржена

git diff --stat master..newbranch
^^^
обзор по изменениям в файлах между master и newbranch!

git log -p master..newbranch | git shortlog
^^^
список коротких комментов к коммитам между master и newbranch

git archive --format=tar --prefix=project/ HEAD > release.tar
^^^
Создание тарбола из состояния HEAD
Файлы положат в директорию project/

git log e2k.oldstable.gstuff --pretty=format: --name-only --diff-filter=A | sort - >& list.files
^^^
Просмотр всех файлов

Копирование себе репозитория

vim ~/.gitconfig

[user]
         name = ton
         email = ton@sample.ru
[i18n]
    commitencoding = ru_RU.UTF-8

rm -rf ./repo
git clone -n --template /dir/git/templates /auto/allarch/osfs.git ./repo
cd ./repo
git fetch origin slack.stable.current:slack.stable.current
git checkout slack.stable.current

Обновление удалённого репозитария
git push /auto/allarch/osfs.git slack.stable.current:slack.stable.current

Обновление рабочего репо с удалённого репозитория
git pull /auto/allarch/osfs.git slack.stable.current

Срезание новой ветки newbranch 

git branch newbranch

Переключение на ветвь
git checkout slack.debug

сливание ветки new в ветку main

git checkout main
git merge new

Спасительная команда undo:
git reset --hard HEAD

git diff branch1..branch2 file.txt
^^^
выдаём diff для файла для изменений, которые есть в branch2, но нет в branch1

git fetch 
команда, качающая внутренние структуры гиторепозитариев с удалённых мест

Посмотреть, какие ветки есть в произвольном удалённом репозитории (не в том, с которого склонировали)
git remote add svetlana /home/shishor_s/repo
git fetch svetlana
git branch -r
^^^
теперь команда будет показывать её ветки среди всех остальных удалённых
(других таких же добавленных и того, с которого склонировали главный репо)


-------------------------------------------------

Действия по запиливанию удалённого репозитория

git init
^^^
создаём нулевой репо 
ssh-keygen -t rsa -C "net@rlib.su"
^^^
генерим пару rsa-ключей
git remote add origin git@github.com:rlib/allinfo.git
^^^
связываемся с удалённым серваком
git push -u origin master
^^^
заливаем всё из ветки master
git push origin base.fresh:base.fresh
^^^
заливаем всё из ветки base.fresh и одновременно создаём эту ветку, если её не было

Доступ из-под прокси к удалённому гит-репо!

ставим программу для форвардинга ssh-трафика через http - 
corkscrew

дальше создаём ~/.ssh/config, туды пишем:

Host github.com
  ProxyCommand /path/to/corkscrew proxy.host.com 80 %h %p
  User git
  Hostname ssh.github.com
  PreferredAuthentications publickey
  Port 443
  IdentityFile "/path/to/.ssh/id_rsa"
  TCPKeepAlive yes
  IdentitiesOnly yes

И всё, git дотягивается до github как ни в чём ни бывало
