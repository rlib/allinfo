Round 2!!

Установка слаки на стационаре amd с четырьмя ядрами
Во-первых, начинаем эксперименты себе на голову:
Вместо стандартного MBR размечаем диск по схеме GPT!
Создаём SystemRescueDisk вот отсюда, инструкции на сайте по созданию очень простые:
http://www.sysresccd.org/Download
Образ пишем на флешку и на целевой машине грузимся с неё

(Собсно, предыстория сего эксперимента - попытка поставить Funtoo, которая обломалась из-за нерабочего dhcpcd, но это только до поры до времени)

Далее, загрузившись, размечаем хард по инструкции отсюда:
http://www.funtoo.org/wiki/Funtoo_Linux_Installation

Юзаем gdisk, который почти такой же, как fdisk, только для GPT-таблиц
Разделов 4 обязательных:
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048          206847   500.0 MiB   8300  Linux filesystem
   2          206848          272383   32.0 MiB    EF02  BIOS boot partition
   3          272384         8660991   4.0 GiB     8200  Linux swap
   4         8660992       234441614   107.7 GiB   8300  Linux filesystem
Но последний раздел сделал маленьким, а оставшийся диск оставил неразмеченным, для последующих систем
Места под swap грохнул 8 гигов, типа на вырост для оперативы, 2*RAM какбэ

У Слаки в поставке идёт только LILO, только хардкор - а для GPT формата нужен grub
Поэтому делаем ход конём - при установке Слаки Лило не ставим вообще; а потом создаём загрузочную флешку, которая умеет бутиться в созданный корневой раздел! Есть такая функция, очень полезная
И пока с флеши позагружаемся, до груба

~~~~~~~~~~~~~~~

Сеть работает из коробки через DHCP

~~~~~~~~~~~~~~~

Для взлёта Иксов достаточно было поставить ATI-шный видеодрайвер с сайта http://support.amd.com/us/gpudownload/Pages/index.aspx
+ пускануть конфигурилку
aticonfig --initial --input=/etc/X11/xorg.conf

В 14-й Слаке на ядре 3.2.29 открытые дрова неплохо работали, и Иксы с ними взлетали
Были такие косяки: консольный framebuffer был весь в поперечных мигающих полосах, а в Кедах на перерисовке окон периодически на долю секунды дёргалась кривая картинка
Но графика работала и быстро - не медленнее, чем с патентованным драйвером

Драйвер версии 12.8 (amd-driver-installer-8.982-x86.x86_64) нормально встаёт на ядра 3.2.*

~~~~~~~~~~~~~~~

User adding:
useradd -m -G users,disk,lp,wheel,floppy,mail,audio,video,cdrom,games,plugdev,power,scanner -s /bin/bash ton

~~~~~~~~~~~~~~~

Русификация utf-8 блеадь!

Ядро надо грузить с параметром
vt.default_utf=0
Без этого любой русиш будет отображаться квадратиками

Файло:
/etc/rc.d/rc.keymap
 /usr/bin/loadkeys /usr/share/kbd/keymaps/i386/qwerty/ruwin_cplk-UTF-8.map.gz

# в более старых Слаках нужно докопировать отдельно раскладку 
#http://mlclm.narod.ru/ru-utf.map.gz
#(Оно же в личном slack-postinst-packs наборе)
#cp ru-utf.map.gz /usr/share/kbd/keymaps/i386/qwerty
# /usr/bin/loadkeys /usr/share/kbd/keymaps/i386/qwerty/ru-utf.map.gz
#Переключение между языками будет по правому Alt + Shift

/etc/rc.d/rc.font
# This selects your default screen font from among the ones in
# /usr/share/kbd/consolefonts
unicode_start cyr-sun16

#setfont -v
#unicode_start LatArCyrHeb-16
# в одном из мануалов встречались вот такие заклинания, для чего они - не знаю
#for i in 1 2 3 4 5 6;do
#echo -ne "\033%G" >/dev/tty$i
#done

/etc/profile.d/lang.sh
export LANG=ru_RU.UTF-8
# системные телеги будут английскими
export LANG_MESSAGES="C"

Do not forget!!
chmod +x /etc/rc.d/rc.font
chmod +x /etc/rc.d/rc.keymap
chmod +x /etc/profile.d/lang.sh

%%%%

Настройка Кед, чтобы меню были на английском:
Настройки системы -> Локаль -> Добавить язык, british english

В Konsole для отображения буковок нужно не забыть кодировку выставить в utf8

Переключение раскладки в Иксах:
нужно, чтобы запускалась строка:
setxkbmap -layout "us, ru" -option "grp:caps_toggle,grp_led:scroll"

Её нельзя поместить в /etc/rc.d/*, на момент выполнения вещей оттуда Иксы не подняты
Больше того, /etc/X11/xinit/xinitrc для этого тоже не пригоден
Потому что там только запускается графический вход, а после его запуска управление в скрипт уже не передаётся

По логике, его надо помещать в скрипты, которые выполняются после загрузки окон, типа графический аналог для /etc/rc.d/rc.local
Этот аналог оконно-зависимый, типа для каждой среды свой
Для Кед сделаем так:
touch /etc/rc.d/rc.postxinit
chmod +x /etc/rc.d/rc.postxinit
Пишем туда строку
ln -s /etc/rc.d/rc.postxinit ~/.kde/Autostart

Что примечательно, в /etc/X11/xorg.conf эта строка есть даже по умолчанию - и она конечно не работает

Для xfce4 можно открыть Настройки -> Сеансы и Запуск, и добавить в автозапуск при входе произвольную команду со своим описанием
Дописал туда 
sh /etc/rc.d/rc.postxinit

%%%%

Теперь танцы с бубном для правильной работы с русским под рутом!
Файл /etc/profile.d/lang.sh загружается при любом логине в систему только под условием:
if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then

Отсюда:
mkdir -p /etc/sysconfig
touch /etc/sysconfig/i18n

Теперь при логине под рутом будет выставляться правильная локаль

%%%%

#Есть также действия для алиасов локалей - однако про них пишут, 
#что они устарели и все локали должны называться полностью
#В последней настройке не применялось

для консоли
/usr/share/locale/locale.alias
#изменяем строчку
#russian ...
#на
russian ru
ru ru_RU
ru_RU ru_RU.UTF-8
для иксов
/usr/lib/X11/locale/locale.alias

~~~~~~~~~~~~~~~

Настройка sudo

visudo
раскомменчиваем строчку:
 %wheel ALL=(ALL) ALL

Чтобы при вызове sudo сохранялись данные о графической сессии юзера и можно было открывать новые граф.приложения, нужно под юзером явно взводить переменную XAUTHORITY - тогда она будет сохраняться и под sudo
В XAUTHORITY хранится файл с печеньем о графической сессии

# ::rasp взводим XAUTHORITY явно
if [ -f $HOME/.Xauthority ] ; then
    export XAUTHORITY=$HOME/.Xauthority
fi
FIXME
В какой файл это писать - ныне непонятно! Сейчас записано в самописный /etc/rc.d/rc.postxinit, но при запуске из $HOME/.kde/Autostart взведение этой переменной не работает : (

%%%%

Настройка su
Переходить в su нужно:
su -l
^^^
Такой вызов сохраняет пользовательские переменные окружения (за исключением некоторых)
Локаль и XAUTHORITY в этом случае будут сохраняться нормальными

~~~~~~~~~~~~~~~

Монтирование харда
mount /dev/sdb2 /mnt/dark

Нужно скопировать из текущего /home/ton настройки от кед и прочего актуального в /mnt/dark, удалить из /mnt/dark всё, что может помешать примонтировать директорию как нынешний /home/ton; затем:

/etc/fstab
/dev/sdb2        /home/ton            reiserfs	      defaults         0   0

~~~~~~~~~~~~~~~

Настройка прочих нужных действий по умолчанию при загрузке

Загрузка в графику по умолчанию

/etc/inittab
# ::rasp настраиваем графику на логине
#id:3:initdefault:
id:4:initdefault:

Чтобы нормально работали графические приложения под su/sudo, нужно их настроить (см. выше)

%%%%

Делаем так, чтобы подрубался .bashrc при загрузке - почему-то по умолчанию этого не происходит

touch /etc/profile.d/bash.sh
chmod +x /etc/profile.d/bash.sh
Пишем туда:

#!/bin/bash

#::rasp вручную подключаем .bashrc при логине
if [ -f $HOME/.bashrc ] ; then
        . $HOME/.bashrc
fi

Файл наряду с другими файлами *.sh будет исполняться при загрузке /etc/profile, который выполняется при логине любого пользователя

%%%%

Подхачиваем настройку сети:
В машине две карточки, eth0 + eth1, из них провод воткнут в eth1
Пишем в /etc/rc.d/rc.inet1.conf:

# Config information for eth0:
...
USE_DHCP[0]="no"

# ::rasp выставляем значение USE_DHCP для eth1
# Config information for eth1:
...
USE_DHCP[1]="yes"

%%%%

Чиним загрузку /etc/rc.d/rc.local

Может статься так, что rc.local не грузится
Это может быть, если любой скрипт из /etc/rc.d/rc.M завершился аварийно, и тогда всё, что за ним, не выполнится
А rc.local всегда последний
Диагностировать поможет вывод в /var/log/messages от всех скриптов, и неправильный скрипт можно запускать так:
( . /etc/rc.d/rc.error )
Это запустит скрипт в новом суб-шелле, который работает независимо от вызывающего, и не грохнет его следом за собой
Но! Все подряд так оборачивать нельзя, потому что это убьёт экспорт переменных из этих скриптов
Нужно глазами смотреть, что там ничего нужного не взводится

~~~~~~~~~~~~~~~

Настройка фреймбуфера
Для включения более красивой консоли достаточно передавать ядру vga=режим, включится старый framebufer VESA
Чтобы узнать режимы, можно при boot в syslinux нажать F1
(чтобы не грузилось сразу по умолчанию, в syslinux.cfg поставить параметр prompt 1)
У меня заработал vga=793
Более старшие он может не узнать и потребовать ввести их ещё раз в 16-чном формате (с новой таблицей для них), и оттуда уже узнает
