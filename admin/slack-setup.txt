Round 2!!

Установка слаки на стационаре amd с четырьмя ядрами
Во-первых, начинаем эксперименты себе на голову:
Вместо стандартного MBR размечаем диск по схеме GPT!
Создаём SystemRescueDisk вот отсюда, инструкции на сайте по созданию очень простые:
http://www.sysresccd.org/Download
Образ пишем на флешку и на целевой машине грузимся с неё

(Собсно, предыстория сего эксперимента - попытка поставить Funtoo, которая обломалась из-за нерабочего dhcpcd, но это только до поры до времени)

Далее, загрузившись, размечаем хард по инструкции отсюда:
http://www.funtoo.org/wiki/Funtoo_Linux_Installation

Юзаем gdisk, который почти такой же, как fdisk, только для GPT-таблиц
Разделов 4 обязательных:
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048          206847   500.0 MiB   8300  Linux filesystem
   2          206848          272383   32.0 MiB    EF02  BIOS boot partition
   3          272384         8660991   4.0 GiB     8200  Linux swap
   4         8660992       234441614   107.7 GiB   8300  Linux filesystem
Но последний раздел сделал маленьким, а оставшийся диск оставил неразмеченным, для последующих систем
Места под swap грохнул 8 гигов, типа на вырост для оперативы, 2*RAM какбэ

У Слаки в поставке идёт только LILO, только хардкор - а для GPT формата нужен grub
Поэтому делаем ход конём - при установке Слаки Лило не ставим вообще; а потом создаём загрузочную флешку, которая умеет бутиться в созданный корневой раздел! Есть такая функция, очень полезная
И пока с флеши позагружаемся, до груба

~~~~~~~~~~~~~~~
Этап второй - борьба с ебучей сетью

Всё это ниже - было не нужно, сеть работала совсем из-за другого
/*
dhcpcd упорно не работает под обоими дистрибутивами - gentoo, слакой, и systemcd, то есть тремя даже
При том что по тому же самому проводу Слака на нетбуке поднимает сеть по первому тычку
Отсюда мысль, что виноваты вовсе не версии dhclient, а сетевые карточки
А конкретно - вот эта:
Realtek Semiconductor Co, RTL8111/8168B PCI Express (rev 06)

И таки действительно, не ты первый с такой пичалью:
http://forums.gentoo.org/viewtopic-p-6927176.html

Оказывается, драйвер под эту карту, вкомпиленный в ядро - кривой:
lspci -v | less
Ethernet Controller, blah-blah
Kernel driver in use: r8169
Вот эту хрень нужно отстреливать сразу
Причём это актуально для карт Realtek, у которых rev не очень низкий - по крайней мере не 01, не 02 - чуваки с ними рапортовали, что всё ок; у меня rev 06

А вот рецепт, как собрать руками свой нормальный модуль:
http://amk1.wordpress.com/2009/06/09/realtek-8168-module-issue/

Исходник лежит здесь:
http://www.realtek.com/downloads/downloadsView.aspx?Langid=1&PNid=13&PFid=5&Level=5&Conn=4&DownTypeID=3&GetDown=false

Собрать его:
make clean modules && make install

Далее выпилить текущий кривой драйвер:
rmmod r8169
depmod
modprobe r8168
update-initramfs -u (!!) 
*/

Выяснилось, что провайдер привязывался к MAC-адресу и новую карточку не подрубал
Волшебный звонок всё решил, и сеть изначально была рабочей
~~~~~~~~~~~~~~~

Для взлёта Иксов достаточно было поставить ATI-шный видеодрайвер с сайта http://support.amd.com/us/gpudownload/Pages/index.aspx
+ пускануть конфигурилку
aticonfig --initial --input=/etc/X11/xorg.conf

%%%%

Добавка для ядра 3.2 и выше!!
С новыми исходниками дефолтный драйвер компилиться перестал
Мануал, как теперь с этим жить, здесь:
http://wiki.cchtml.com/index.php/Fedora_16_Installation_Guide
(секция "проблемы для i686")

Команды оттуда:

INSTALLER=amd-driver-installer-12-4-x86.x86_64.run
dirInst=fglrx-12.4
TOP=$(pwd)
chmod 700 $INSTALLER
./$INSTALLER --extract $dirInst
cd $dirInst/common/lib/modules/fglrx/build_mod

echo "\
fixed fgrlx compilation error on 32-bit x86 arch with kernel 3.3-rc4 due to commit:
https://github.com/torvalds/linux/commit/f94edacf998516ac9d849f7bc6949a703977a7f3
later modified (in 3.3-rc5) by commit:
https://github.com/torvalds/linux/commit/7e16838d94b566a17b65231073d179bc04d590c8#diff-1
and finally backported to kernel 3.2.8.

Signed-off-by: Gianluca Gennari <gennarone@gmail.com>
---
 firegl_public.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/firegl_public.c b/firegl_public.c
index 6e0aa82..cb9e217 100644
--- a/firegl_public.c
+++ b/firegl_public.c
@@ -5797,10 +5797,16 @@ void ATI_API_CALL KCL_fpu_begin(void)
 #ifdef CONFIG_X86_64
     kernel_fpu_begin();
 #else
+#ifndef TS_USEDFPU
+    preempt_disable();
+    if (__thread_has_fpu(current))
+        __save_init_fpu(current);
+#else
     struct thread_info *cur_task = current_thread_info();
     preempt_disable();
     if (cur_task->status & TS_USEDFPU)
         __save_init_fpu(cur_task->task);
+#endif
     else
         clts();
 #endif
-- 
1.7.5.4
" > fglrx.patch

patch -p1 < ./fglrx.patch
cd $TOP/$dirInst

sudo ./ati-installer.sh 8.95 --install

~~~~~~~~~~~~~~~

User adding:
useradd -m -G users,disk,lp,wheel,floppy,mail,audio,video,cdrom,games,plugdev,power,scanner -s /bin/bash ton

~~~~~~~~~~~~~~~

Русификация utf-8 блеадь!

Ядро надо грузить с параметром
vt.default_utf=0
Без этого любой русиш будет отображаться квадратиками

Файло:
/etc/rc.d/rc.keymap
 /usr/bin/loadkeys /usr/share/kbd/keymaps/i386/qwerty/ruwin_cplk-UTF-8.map.gz

# в более старых Слаках нужно докопировать отдельно раскладку 
#http://mlclm.narod.ru/ru-utf.map.gz
#(Оно же в личном slack-postinst-packs наборе)
#cp ru-utf.map.gz /usr/share/kbd/keymaps/i386/qwerty
# /usr/bin/loadkeys /usr/share/kbd/keymaps/i386/qwerty/ru-utf.map.gz
#Переключение между языками будет по правому Alt + Shift

/etc/rc.d/rc.font
# This selects your default screen font from among the ones in
# /usr/share/kbd/consolefonts
unicode_start cyr-sun16

#setfont -v
#unicode_start LatArCyrHeb-16
# в одном из мануалов встречались вот такие заклинания, для чего они - не знаю
#for i in 1 2 3 4 5 6;do
#echo -ne "\033%G" >/dev/tty$i
#done

/etc/profile.d/lang.sh
export LANG=ru_RU.UTF-8
# системные телеги будут английскими
export LANG_MESSAGES="C"

Do not forget!!
chmod +x /etc/rc.d/rc.font
chmod +x /etc/rc.d/rc.keymap
chmod +x /etc/profile.d/lang.sh

%%%%

Настройка Кед, чтобы меню были на английском:
Настройки системы -> Локаль -> Добавить язык, british english

В Konsole для отображения буковок нужно не забыть кодировку выставить в utf8

Переключение раскладки в Иксах:
нужно, чтобы запускалась строка:
setxkbmap -layout "us, ru" -option "grp:caps_toggle,grp_led:scroll"

Её нельзя поместить в /etc/rc.d/*, на момент выполнения вещей оттуда Иксы не подняты
Больше того, /etc/X11/xinit/xinitrc для этого тоже не пригоден
Потому что там только запускается графический вход, а после его запуска управление в скрипт уже не передаётся

По логике, его надо помещать в скрипты, которые выполняются после загрузки окон, типа графический аналог для /etc/rc.d/rc.local
Этот аналог оконно-зависимый, типа для каждой среды свой
Для Кед сделаем так:
touch /etc/rc.d/rc.postxinit
chmod +x /etc/rc.d/rc.postxinit
Пишем туда строку
ln -s /etc/rc.d/rc.postxinit ~/.kde/Autostart

Что примечательно, в /etc/X11/xorg.conf эта строка есть даже по умолчанию - и она конечно не работает

%%%%

Теперь танцы с бубном для правильной работы с русским под рутом!
Файл /etc/profile.d/lang.sh загружается при любом логине в систему только под условием:
if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then

Отсюда:
mkdir -p /etc/sysconfig
touch /etc/sysconfig/i18n

Теперь при логине под рутом будет выставляться правильная локаль

%%%%

#Есть также действия для алиасов локалей - однако про них пишут, 
#что они устарели и все локали должны называться полностью
#В последней настройке не применялось

для консоли
/usr/share/locale/locale.alias
#изменяем строчку
#russian ...
#на
russian ru
ru ru_RU
ru_RU ru_RU.UTF-8
для иксов
/usr/lib/X11/locale/locale.alias

~~~~~~~~~~~~~~~

Настройка sudo

visudo
раскомменчиваем строчку:
 %wheel ALL=(ALL) ALL

Чтобы при вызове sudo сохранялись данные о графической сессии юзера и можно было открывать новые граф.приложения, нужно под юзером явно взводить переменную XAUTHORITY - тогда она будет сохраняться и под sudo
В XAUTHORITY хранится файл с печеньем о графической сессии

# ::rasp взводим XAUTHORITY явно
if [ -f $HOME/.Xauthority ] ; then
    export XAUTHORITY=$HOME/.Xauthority
fi
FIXME
В какой файл это писать - ныне непонятно! Сейчас записано в самописный /etc/rc.d/rc.postxinit, но при запуске из $HOME/.kde/Autostart взведение этой переменной не работает : (

%%%%

Настройка su
Переходить в su нужно:
su -l
^^^
Такой вызов сохраняет пользовательские переменные окружения (за исключением некоторых)
Локаль и XAUTHORITY в этом случае будут сохраняться нормальными

~~~~~~~~~~~~~~~

Монтирование харда
mount /dev/sdb2 /mnt/dark

Нужно скопировать из текущего /home/ton настройки от кед и прочего актуального в /mnt/dark, удалить из /mnt/dark всё, что может помешать примонтировать директорию как нынешний /home/ton; затем:

/etc/fstab
/dev/sdb2        /home/ton            reiserfs	      defaults         0   0

~~~~~~~~~~~~~~~

Настройка прочих нужных действий по умолчанию при загрузке

Загрузка в графику по умолчанию

/etc/inittab
# ::rasp настраиваем графику на логине
#id:3:initdefault:
id:4:initdefault:

Чтобы нормально работали графические приложения под su/sudo, нужно их настроить (см. выше)

%%%%

Делаем так, чтобы подрубался .bashrc при загрузке - почему-то по умолчанию этого не происходит

touch /etc/profile.d/bash.sh
chmod +x /etc/profile.d/bash.sh
Пишем туда:

#!/bin/bash

#::rasp вручную подключаем .bashrc при логине
if [ -f $HOME/.bashrc ] ; then
        . $HOME/.bashrc
fi

Файл наряду с другими файлами *.sh будет исполняться при загрузке /etc/profile, который выполняется при логине любого пользователя

%%%%

Подхачиваем настройку сети:
В машине две карточки, eth0 + eth1, из них провод воткнут в eth1
Пишем в /etc/rc.d/rc.inet1.conf:

# Config information for eth0:
...
USE_DHCP[0]="no"

# ::rasp выставляем значение USE_DHCP для eth1
# Config information for eth1:
...
USE_DHCP[1]="yes"

%%%%

Чиним загрузку /etc/rc.d/rc.local

Может статься так, что rc.local не грузится
Это может быть, если любой скрипт из /etc/rc.d/rc.M завершился аварийно, и тогда всё, что за ним, не выполнится
А rc.local всегда последний
Диагностировать поможет вывод в /var/log/messages от всех скриптов, и неправильный скрипт можно запускать так:
( . /etc/rc.d/rc.error )
Это запустит скрипт в новом суб-шелле, который работает независимо от вызывающего, и не грохнет его следом за собой
Но! Все подряд так оборачивать нельзя, потому что это убьёт экспорт переменных из этих скриптов
Нужно глазами смотреть, что там ничего нужного не взводится

~~~~~~~~~~~~~~~

