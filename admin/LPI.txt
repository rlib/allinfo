Часть 1

==========================================
==========================================

Глава 1

--------------------------
1.1 Узнать объём ОЗУ компа


free -m
^^^
ключ -m выдаёт в мегабайтах, -l - детальную статистику

cat /proc/meminfo
^^^
(куча подробных хар)

--------------------------
1.2 Узнать свободное дисковое пространство 

df -h
^^^
Ключ -h для вывода в human-ридебл формате, с указанием единиц

==========================================
==========================================

Глава 2

2.1 name+passwd, на выход exit, logout, либо ctr+D
выдаёт uname -a на tty1, last login тогда-то
2.2 на кривом логине приглашение пароля выдаётся
2.3 при кривом логине или кривом пароле сообщение одно - login incorrect
2.4 set -o ignoreeof, отключает Ctr+D, если теперь нажать - 
пишет "юзайте logout для выхода" (в графике), в консоли пишет про logout
2.5 ввод кривой команды - bash: кривая команда: команда не найдена

PAM - Pluggable Authentication Module - набор библиотек для авторизации\идентификации юзеров.

2.6 установка пароля себе - passwd
установка пароля другому от рута - passwd username
2.7 установка кривого пароля: linux123 прекрасно поставился, а вот старый из цифр выдал:
НЕВЕРНЫЙ ПАРОЛЬ: it does not contain enough DIFFERENT characters
НЕВЕРНЫЙ ПАРОЛЬ: it does not contain enough DIFFERENT characters
НЕВЕРНЫЙ ПАРОЛЬ: it does not contain enough DIFFERENT characters
passwd: Использовано максимальное число попыток, заданное для службы
passwd: password unchanged
Из-под рута же ругается (один раз), но меняет

2.8 UID - user ID, GID - group ID
вывод uid и всех gid
id
^^^
юзерские id начинаются с 1000
настройки:
cat /etc/login.defs
^^^
2.9 к каким группам принадлежу:
groups
^^^
или для gid-ов:
id -G
^^^
2.10
UID\GID рута - 0, группы рута в диапазоне меньше 1000
2.11 Только UID:
id -u
^^^
Только primary gid:
id -g
^^^
(группа, которая ставится в создаваемые юзером файлы)

2.12 кто сидит в системе:
(с заголовком к таблице)
who -H
^^^
В скобках справа должно быть имя машины, но у меня какая-то херь
Есть псевдотерминал - начинается с pts
Есть просто терминал, tty
на каком терминале сидишь сейчас:
tty
who читает данные из /var/run/utmp (файл бинарный)
2.13 кто что делает в системе:
w
^^^
там указана команда
2.14 Кто заходил раньше:
last
^^^
читает из /var/log/wtmp
2.15
who /var/log/wtmp 
^^^
работает, только обрезает лог под свой формат

2.16 оболочка при загрузке:
echo $SHELL
^^^
хотя это конечно весьма на соплях
2.17 можно ещё набрать echo $SHELL, а потом вместо Enter жать Ctrl+J
Ctr+J - замена ентеру на горячих клавишах в баше:
1) чтобы можно было пользоваться на убитых терминалах, где спец-клавиши
вообще не работают никакие
2) чтобы можно было жать ентер, не отрывая руки от букв и не сбрасывая
турбо-скорость

2.18 - выполнили ls дома
2.19 - ls - имя, -l - опция, ~ - аргумент;
2.20 --help - длинный префикс у гнутых
2.21 - список шеллов в системе
cat /etc/shells
^^^
2.22 - вот только это список возможных шеллов; по факту же ни один 
не установлен, кроме sh и bash
А так - tcsh, exit
2.23 tcsh --version
2.24 tcsh --help - есть ли? похоже, что нет
2.25 - и корн-шелла тоже нету
Ухты, есть шняга /usr/bin/chsh - программа для смены шелла

2.26 - ls /bin | less - дети, подойдём к ведру
2.27 pwd --help - ключ от builtin команды оболочки не пашет
/bin/pwd --help - гнутый pwd уже поддерживает ключ
2.28 команда type офигенная штука
type
^^^
вся инфа про то, что из себя команда представляет
(алиас, встроенная в шелл команда или аналог which)
Сама type, кстати, shell builtin

2.29 - type disable, disable мы не нашли; 
не является встроенной в bash 3.2.33 и в 4.сколько-то

Охрененная штука - горячие клавиши для редактирования команд!
Ctrl + B = курсор влево 
Ctrl + F = курсор вправо
Ctrl + A = курсор в начало строки
Ctrl + E = курсор в конец строки
Ctrl + H = удаление символа перед курсором
Ctrl + D = удаление символа на самом курсоре
Ctrl + J = Ввод
Ctrl + L = чистим экран
Alt  + T = перемена мест аргументов (!)
Ctrl + C = кирдык
Ctrl + Z = приостанов задания
Ctrl + R = поиск команды в истории (!)
Ctrl + W = удаление слова до курсора 
Ctrl + U = удаление от курсора до начала
Ctrl + K = удаление от курсора до конца
Ctrl + P = показать предыдущую команду
Ctrl + N = показать следующую команду
Ctrl + Y = вставить удалённое
Ctrl + Shift + - = отменить удаление
Alt + D = удалить от курсора до конца слова
Alt + backspace = удалить от курсора до начала слова
Alt + F = переход на слово вперёд
Alt + B = на слово назад

2.30 ls \ -FR \ ~
ввод команд на разных строках
2.31 hostname ; date
ввод команд в одной строке
2.32 перемена мест команды и аргумента
/etc ls, Alt+T 
А вот фиг, эта комбинация не работает! она поменяет вот так:
/ls etc
она нормально меняет только a-zA-Z0-9, а спец-символы оставляет на месте 

Открыта великая тайна разницы между set и env
env
^^^
env выводит все переменные _окружения_ текущего процесса
set
^^^
set выводит все переменные текущей оболочки
unset
^^^
разопределяет переменную оболочки

Прикольное про переменные окружения:
PWD
^^^
Если заменить PWD, то bash будет это показывать вместо текущей директории
Но эффект живет до первой команды cd
SHLVL
^^^
Показывает уровень вложенности оболочки, для голой консоли - 1, для графической консоли - 2, если поверх зайти ещё в одну - будет 3, и т.д.
PS1
^^^
Мега-переменная для отображения приглашения Bash, у неё куча символов форматирования, всё в документации

2.33 Переменные окружения, выставляемые всем пользователям при логине (входе в сеанс)
/etc/profile
^^^
Переменные окружения, выставляемые конкретным юзерам при логине (входе в сеанс)
~/.bash_profile (~/.bash_login, ~/.profile)
^^^
Переменные оболочки, выставляемые при каждом запуске shell
~/.bashrc
^^^
Вот в чём между ними оказывается разница. Сейчас в .bash_profile стоит исполнение .bashrc, и всё

2.34 имена текущего и домашнего каталогов
echo $PWD ; echo $HOME
2.35 NEWVAR=1982, в порождённой оболочке недоступна
2.36 export NEWVAR, в порождённой оболочке доступна
2.37 set ; env

~/.bash_history + $HISTFILE + $HISTFILESIZE
^^^
файл для хранения истории; переменная, его задающая; размер хранимой истории
2.38
!!
^^^
вызов последней введённой команды!!
2.39 поиск команды в истории с отображением до исполнения -
Ctr+R
^^^
2.40
!ec
^^^
вызов первой команды с конца, которая начинается на ec
2.41
!?ho
вызов первой команды с конца, в которой содержится строка ho
2.42 ввод -Ctr+R, -F
2.43
history
^^^
вывод истории юзера с номерами команд, хранится и между сеансами успешно, и между запусками оболочек
!499
^^^
Вызов команды из истории по её номеру!!!!
2.44 set HISTFILESIZE=9999, между запусками оболочек не живёт
2.45 ctr+P VS !!
Ctr+P показывает предыдущую команду, не запуская
!! неинтерактивно печатает команду и сразу исполняет
Ctr+P можно использовать вместо стрелки вверх для отмотки команд

2.46
ls -ld /<Tab><Tab>
2.47
$HIST<Tab><Tab>FILES<Tab>

2.47
alias
^^^
список псевдонимов bash текущего сеанса
2.48 почему /bin/ls не подсвечивает цветами
/bin/ls VS ls --color=auto
2.49
alias lf='ls -F'
^^^
создание алиаса вручную
2.50
unalias lf
^^^
удаление алиаса
unalias -a
^^^
сносим все алиасы

2.51 
ls -l $(which ls)
^^^
другой синтаксис для обратных кавычек! = ls -l `which ls`
2.52 по тексту задания
ps -u `whoami`
2.53 по тексту задания
MYGROUP=`id -gn`
2.54
echo $((16*1024*1024))
^^^
синтаксис для вычисления арифметических выражений
2.55 по тексту задания, имя 16MB задать нельзя
MB16=$((16*1024*1024))
2.56 вывод переменной с числом секунд в двух неделях
echo TTL=$((60*60*24*7*2))
2.57 по тексту echo $((2*$HISTFILESIZE))
2.59 по тексту - остатки от делений echo $((7%3)) ; echo $((7%4))

echo *
^^^
выведет все НЕ-скрытые файлы или саму звёздочку!
маска * подходит к любым файлам, кроме скрытых!
?byrvalg
^^^
? означает один любой символ
a[a-z]b
^^^ 
[] - один символ, который может быть из указанного множества;
можно задавать диапазон [A-Z], перечисление [123], отрицание [!a-z]
color{a,b}
^^^
= colora, colorb, механизм перечисления
2.60
ls ?[a,u,o,i,e]*
^^^
шаблон, где вторая буква является гласной
2.61 ??*
вторая буква - любой символ
2.62 шаблон для 6символьных строк, последняя буква - либо не-цифра, либо А
?????{[!1-0],A}
2.63
[*] означает буквально символ звёздочки
2.64
ls /etc/rc.?d


==========================================
==========================================

Глава 3

про помощь и хелпы

3.1 id --help работает - значит, гнутое изделие
3.2 id -h не работает
3.3 wc --help - дети, подойдём к ведру
3.4
help cd
^^^
подсказка по встроенным командам bash!
Гы, CDPATH оказывается содержит набор путей, в которых ищется директория-аргумент cd
Можно задать там несколько путей через : и попадать через cd в разные места, а не только начиная с текущей директории
Там ещё более дремучие штуки есть - типа переменной cdable_vars, если её поставить, bash будет пытаться аргумент cd интерпретировать как имя переменной, куда сиди-кать (если обычная нормальная директория по CDPATH не нашлась)
3.5
help alias
^^^
Хе, в моей версии alias и alias -p одно и то же

Ыыы, офигенно - разделение манов по тематикам\разделам

man 3 zlib
^^^
Ман о библиотеке zlib

Таблица категорий манов:
1 - Команды пользователя
2 - Системные вызовы ядра
3 - Библиотеки
4 - Файлы устройств и спец.файлы
5 - Форматы конфигов
6 - Помощь по играм ))))))
7 - Макросы, кодировки, погромистам
8 - Команды сисадминам
9 - Функции ядра
n - команды языка TCL (!)
1x - маны по иксам

И что ещё интересно - man не отображает страницы, только ищет и форматирует, а отображением занимается уже less или что-то другое вместо неё
Команды у less те же, что у вим

3.6 man man
3.7 
man -P /usr/bin/less
^^^
задаёт просмотрщик для ман-страниц
3.8
man -k
^^^
apropos
^^^
одно и то же - поиск подстроки по всем файлам man в их секции NAME

man -f
^^^
whatis
^^^
поиск точного совпадения данной строки и секции NAME у man-страницы

Оказывается, маны пишутся на языке разметки ROFF
а groff - это гнутая хрень для чтения этого языка

Всякое о конфигах man:
/usr/share/man/ru - путь до русифицированных страниц
$MANPATH - дополнительные пути доступа к манам, её можно ставить через 
manpath
^^^
/etc/main.config
^^^
Конфиг для настройки всего о манах
Написать свой ман можно любым текстовиком, но потом его надо будет разметить макросами по правилам groff, наверняка в его документации они есть

3.9 man -f exit
3.10 xzombie.1x - man для Xzombie
3.11 поставим в каталог /usr/local/share/man/man1x
3.12 туда видимо и должен ставить установщик, второй вариант /usr/share/man/man1x

info ls
^^^
система помощи Texinfo
это порождение извращённого чудовища
Промотки по строкам там нет, только по страницам
Ctr + V - страница вперёд
Alt + V - страница назад
кто сумел додуматься до такого больного сочетания?
Alt + > в конец страницы, 
Alt + < в начало страницы, и на рабочем Gentoo это не работает
s<СТР> - поиск строчки
n - следующий узел,
p - предыдущий узел - тоже на отличненько придумали
u - на уровень вверх
l - предыдущая страница
q - выход
Если эти люди писали Emacs, к нему нельзя приближаться на пушечный выстрел
3.13 info who
3.14 нашёл как info, h, u, пробел (это типа переход на уровень глубже), и дальше
отматыванием n через 8 узлов
это адЪ
страницы для этого паноптикума лежат в /usr/share/info
Есть ещё и /usr/share/doc для программной документации, в unix не интегрированной
3.15
ls /usr/share/doc/bash-3.2_p33/
проверка доков по башу
3.16
ls /usr/share/doc/man*
дополнительной инфы по манам - аж в 4 пакетах
3.17
find /usr/share/doc/* -name HOWTO*
есть ли HOWTO-шки в системе (2 нашлось)


==========================================
==========================================

Глава 4

Файлы, каталоги

4.1 ls ~
4.2 ls -a
4.3 ls --all
ls --help | grep -e '--all'
^^^
удобно искать опции, кстати
ls -A
^^^
кажем скрытые файлы, но игнорируем . и ..

Типы файлов! (по выдаче ls -l)
-  - простой файл
d - каталог
l - символьная ссылка
b - блочное устройство (файл для обращения к девайсам, 
    запись на которые идёт блоками, например хард)
c - символьное устройство (файл для девайсов с посимвольными I\O, типа клавы)
p - именованный канал (PIPE, FIFO)
s - сокет
D - doorway (преимущественно в Соляре)
p, s, D - это всё вариации на тему межпроцессного взаимодействия, s, D при этом
ещё и по сети

ls -F
^^^
прикольная штука, выводящая файлы как с фичей в Midnight Commander:
(символы подсказки)
каталоги/ исполнимыйфайл* символссылка@
ls -ld
^^^
инфа о каталоге, а не о внутренностях
4.4
ls -lt
^^^
сортировка по времени последнего изменения, ыыы
ls -lc
^^^
сортировка по времени изменения состояния файла
ls -lu
^^^
сортировка по времени последнего доступа к файлу!
Интересно, чем c или u отличаются от t
4.5
ls -S
^^^
сортировка по размеру
4.6
ls -l /tmp

cd -
^^^
Офигенно!! переход в предыдущий каталог!!
4.7 cd /tmp
4.8 cd /usr/local/bin
4.9 cd ~ ; pwd
4.10 cd -
4.11 помимо переменных с языками, есть переменные, влияющие на cd:
$CDPATH - набор путей, в которых ищется существование поданного аргумента
(по умолчанию это только текущий каталог)
$HOME - директория, куда ходить без аргументов
$OLDPWD - запоминалка предыдущей диры для cd -
$PWD - как бы переменная текущей директории; если её менять, поведение cd неопределено

4.12
mkdir -p dir1/dir2/dir3/dir4
^^^
создание цепочки вложенных каталогов
rmdir -p dir1/dir2/dir3/dir4
^^^
удаление цепочки пустых каталогов; если где-то что-то будет лежать, 
удалит только до него
ls -lR dir1
^^^
рекурсивная информация о вложенных каталогах
4.13
touch dir1/dir2/Bubuka
^^^
создание файла с временем модификации в "сейчас"
: > dir1/dir2/Bubuka
^^^
либо создание нового, либо затирание старого
4.14 
rmdir -p dir1/dir2/dir3/dir4
после удаления станет dir1/dir2
4.15 rm -rf dir1

4.16 mkdir Toppler ; touch Toppler/{high,low}11 ; cp Toppler/* /tmp
4.17 mv /tmp/{high,low}11 ~
4.18 cp -R Toppler /tmp
4.19 mv /tmp/Toppler /tmp/Roller
4.20 ls -lR /tmp/Roller ; mv /tmp/Roller ~ ; ls -lR ~/Roller

Вкратце про find:
find <опции> <места_поиска> <критерии> <модификаторы>
^^^
опции как-то меняют поведение в общем;
места поиска - просто где ищем
критерии - что ищем
модификаторы - что сделаем, когда найдём

4.21 все пустые файлы в домашнем каталоге:
find ~ -empty
4.22 файлы из /bin между 1 и 10 Кб
find /bin -size +1k -a -size -10k
4.23 снизить диапазон размеров файлов с 1,5 до 2 кб ?
тут фишка в том, что она не даст искать дробное число килобайт
find /bin -size +3b -a -size -2k

locate
^^^
ищет файлы по заданной строке в их названии, используя 
индексированную базу данных имён файлов системы! 
updatedb
^^^
Команда обновления этой базы данных
/var/lib/locatedb
^^^
Вот здесь эта база данных может находиться
В Slackbook-е locate приведена как slocate
В рабочем Gentoo нет такой команды!
whereis
^^^
из Slackbook-а, ищет бинарники, документацию и исходные тексты по имени файла
По ману пути поиска у неё захардкожены
4.24 locate db
4.25 touch filemy ; locate filemy
Типа не найдёт, ибо свежесозданное не попало в базу данных
4.26 su ; updatedb ; exit ; locate filemy
file
^^^
выдаёт тип файла по магическим числам (это база данных сигнатур файлов)
4.27
file . ; file /bin/bash ; file ~/.bashrc
4.28
/usr/share/misc/file/magic.mgc
/usr/share/misc/file/magic
^^^
месторасположение магических чисел; первый - скомпиленный файл, второй текстовик
4.29 file работает по трём типам тестов - файловой системы, магическим числам и "языку".
Первое, что будет успешным, и печатается.
4.30 можно создать собственный тип содержимого, описать его и закинуть в /usr/share/misc/file/magic,
аналогично с тем, что там уже есть

ls -ldi dprof/
^^^
3444704 drwxr-xr-x 3 anikin_a elbrus 4096 Авг 29 12:17 dprof/
второе слева число означает количество имён этого файла
У каталога это собственное имя + точка; подкаталоги добавляют количество имён через .., 
каждый на единицу;
отсюда в dprof один подкаталог
первое число слева (по -i) - номер inode, индексный дескриптор файла
stat
^^^
Подробная информация об inode какого-либо файла
Номера 0, 1, 2 для inode зарезервированы
0 - для удалённых файлов
1 - для будущего, в линуксах для виртуальных ФС от ядра (/proc, /sys)
2 - для / и точек монтирования ФС

4.30 inode родительского каталога от корня:
ls -di /..
2 /..
4.31 
ls -di /home/anikin_a/ ; cd ~ ; ls -di .
совпадает
4.32 ls -l /bin/gzip
количество имён одно
4.33 stat /bin/gzip
ln
^^^
по умолчанию ln делает хардлинки
Хардлинки - разные имена у одного inode, и соответственно у одних данных
Хардлинки могут быть только в пределах одной и той же ФС
Хардлинки на директории - это механизм точек . и ..
Руками хардлинки на директории не создашь
cp -l
^^^
создание хардлинков вместо копирования
4.34 
echo 'blah-blah' > file1 ; ln file1 link1
4.35 mv link1 /tmp
при переносе этого файла в директорию на другой ФС у него стал другой inode
4.36 хардлинки с директориями не разрешаются
ln ~ ./fff
4.37 FIXME Как можно создать жёсткую связь с именем домашнего каталога? Хз как
При копировании директории через cp -l создаётся новая директория, inode увеличивается на 1 
по сравнению со старой
cp -s
^^^
Вместо копирования создавать символьные ссылки
4.38 ln -s /usr/share/doc ~/lala ; cd ~/lala
4.39 FIXME Как получить список символьных ссылок в каталоге? (то бишь только их без остального)
4.40 ln -s /bin/ls ~/avav ; ~/avav /usr

cp -af
^^^
отличная команда для архивирования\накладывания патчей
a - архив, сохранение файлов "как они есть" по всем путям
f - перезаписывать в случае брыкающихся правов на запись

==========================================
==========================================

Глава 5

Процессы

5.1 
man stdin
^^^
Помощь про потоки ввода\вывода\ошибок для процессов
5.2 tty
jobs
^^^
показать процессы в фоновом режиме в текущей консоли(!)
blabla &
^^^
собсно, запуск процесса в фоновом режиме
В foreground у нас всегда один, в background - можно напихать много
Когда фигачишь с процессами, фоновые адресуются через %
kill %2
^^^
убить фоновый процесс по номеру, который кажет jobs
(этот номер называется номером задания)
kill %%
^^^
убить последний запущенный процесс
fg %1
^^^
перевести процесс с номером из фонового режима в интерактивный
Ctr+Z, bg %1
^^^
перевод запущенного задания из интерактивного режима в фоновый
fg %fi
^^^
всё то же самое, с идентификацией по началу команды (!)
5.3 find ~ -empty &
или! find ~ -size 0k &
5.4 
sleep 200 &
sleep 2000 & 
jobs
с амперсандом команды в одну строчку запустить уже не получается!
5.5
kill %2
Для убитого задания jobs кажет статус Terminated (в первый раз)
Для завершённого задания - Done
