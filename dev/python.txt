Пра Питон

*********
Пра установочные пакеты
(В историческом порядке)

setuptools - один из базовых пакетов для установки
Содержит скрипт easy_install, который типа стал известным за какое-то время
Тем не менее, модуль встроенным в Питон не является - мне вот его ставить пришлось; из встроенного вроде как есть нечто distutils.core

Дальше у setuptools есть форк - distribute, мол поумнее и меньше насекомых
Дальше - pip, тоже распространённая штука, типа чтобы ставить \ качать пакеты
А setuptools и distribute - они для использования внутри твоего кода, чтобы оформлять его как пакет!
Типа того

*********
pip - тулза для управления питонопакетами

Основные команды

pip install packname
^^^
поставить новый

pip install --upgrade packname
^^^
обновить

pip uninstall packname
^^^
снести

pip install https://github.com/pypa/virtualenv/tarball/develop
^^^
что клёво, он умеет брать адреса и репозитарии!

*********
nose - расширение для встроенного модуля для тестов (unittest)
мол чтобы все тесты писались легко, и более-менее функционально и быстро

virtualenv - пакет для создания изолированного Питон-окружения
типа можно делать дофига питон-рутов с разными библиотеками, интерпретаторами и тыды

python virtualenv.py ENV
^^^
создание в директории ENV рута для питона
ENV/bin
ENV/lib
и тыды

source ENV/bin/activate
^^^
забить в PATH ENV/bin

virtualenv ENV
^^^
по идее тоже можно

*********
setup.py - скрипт для установки своего кода как модулей в систему

это типа модуль из distutils.core/setuptools/distribute, который надо вызывать через собственную обёртку setup.py, заполнив словарь с ключевыми параметрами - описание, урл проекта, и тыды
Все эти пункты он кстати выдаёт по опциям, их список python setup.py --help-commands / python setup.py --help

Принцип у него такой: есть скелетон, в котором в корне лежит сам setup.py, директория с именем модуля, дира с тестами и дира bin
То, что в директории <modname> - это библиотеки
То, что в bin - это исполнимые файлы
Через setup.py это можно поставить в систему
sudo python setup.py install

Он поставит всё в
/usr/lib/python2.6/site-packages/<projname>-0.1-py2.6.egg, внутри будет <modname> и мета-инфа EGG-INFO с зависимостями и прочим
При этом файлы .py он скомпилит в pyc
После установки можно делать import modname из любого скрипта - он известен на всю систему

Чтобы установились исполнимые скрипты, надоть их указать ко ключу словаря 'scripts', причём с путями, он их автоматически не определяет в bin! Типа bin/one.sh, bin/two.sh
Тогда он их будет устанавливать автоматом по общему install
Можно отдельно
python setup.py build_scripts
python setup.py install_scripts

После этого у тебя есть исполнимый файл more-mega-ex46.py!
В питоновских скриптах он фиксит заголовок с #!/bin/python, подставляя нужный путь к интерпретатору

sudo pip uninstall trymode
^^^
А вот так потом можно снести всё, что ты наустанавливал

-----------------------------------------------

nosetests - мега-хрень для автотестирования

В рабочей директории она ищет все имена функций и классов, которые попадают под регулярное выражение тестировочного кода, и запускает их как тестовый случай
регулярное выражение в мане man nosetests, из простых подойдёт test_ или Test_
рабочая директория по умолчанию текущая, но можно указать другую

nosetests tests/ex47_tests.py:test_map
^^^
указание конкретного файла (с тестовым кодом, не с тестируемым!) и конкретного метода для тестирования
файлы можно указывать с путями (абсолютными тоже)

TestClass.test_method
^^^
для тестовых классов

nosetests --plugins -v
^^^
список плугинов для nosetests с инфой о них
плагины выступают как новые опции командной строчки

*****

unittest - встроенный в Питон framework для тестирования
для запуска нужно создать файл, в нём производный класс от unittest.TestCase, и потом этот файл запускать из командной строчки
суть такая же, что в nosetests, но последний погибче и с плагинами
у unittest тьма настроек и методов

*****

doctest - 
тесты, вшитые прям в комменты к функциям
нужно написать запуск функции из питоновского шелла с аргументами, и ожидаемый результат
а потом по той же схеме, что unittest - создавать отдельный модуль, создавать экземпляр класса и запускать
юзать его очень печально, потому что тестовые случаи в коментах - адовое нагромождение
